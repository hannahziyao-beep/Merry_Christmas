<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>粒子圣诞树 · 立体黄星 + 3D树干 + 灯线 + 上下漂浮</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{width:100%;height:100%;display:block}
  .title{
    position:fixed;left:50%;top:6%;transform:translateX(-50%);
    color:#fff;font-family:"Times New Roman",serif;font-size:clamp(20px,5vw,44px);
    letter-spacing:.06em;text-shadow:0 0 12px rgba(255,180,220,.9),0 0 40px rgba(255,120,200,.7);
    pointer-events:none;white-space:nowrap
  }
  .hint{
    position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
    color:#ddd;font-size:13px;opacity:.8;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial
  }
</style>
</head>
<body>
<canvas id="stage"></canvas>
<div class="title">Merry Christmas ✨</div>
<div class="hint">点击暂停 · 滚轮/双指缩放</div>
<script>
(()=>{
const cvs = document.getElementById('stage');
const ctx = cvs.getContext('2d');
let DPR = 1;
const S = { w:0,h:0,cx:0,cy:0,time:0,zoom:1,rot:0, offsetY:0 };

const PARAM = {
  // —— 树体（干净版）——
  H: 420,
  FLUFF_PUSH: 0.10,
  LEVELS: 140,
  BASE_POINTS: 18,
  SPRAY_PER_POINT: 1,
  SPRAY_LEN: 14,
  SPRAY_NOISE: 0.40,
  BRANCH_COUNT: 6,
  BRANCH_SIGMA: 0.45,
  BRANCH_STRENGTH: 0.60,
  SHAPE_EXP: 1.20,
  DOT_BASE: 1.2,
  DOT_GAIN: 1.6,

  // —— 环境 —— 
  RING_RADIUS: 155,
  SNOW_N: 420,

  // —— 3D 树干（圆柱体）——
  TRUNK_RADIUS_RATIO: 0.08,
  TRUNK_HEIGHT_PX: 80,
  TRUNK_AROUND: 28,
  TRUNK_LEVELS: 26,
  TRUNK_DENSITY: 2,
  TRUNK_NOISE: 0.22,
  TRUNK_LIGHT_AZIMUTH: Math.PI*0.15,
  TRUNK_COL_BASE: [114, 78, 43],

  // —— 星星（黄色）——
  STAR_N: 220,
  STAR_COLOR_INNER: 'rgba(255,245,160,1.0)',
  STAR_COLOR_OUTER: 'rgba(255,210,80,0.85)',

  // —— 黄色灯线（Garland）——
  GARLAND_STRANDS: 3,
  GARLAND_TURNS: 5.5,
  GARLAND_POINTS: 520,
  GARLAND_RADIUS_FACTOR: 0.55,
  GARLAND_NOISE: 0.12,
  GARLAND_JITTER_Y: 2.0,
  GARLAND_COL_INNER: 'rgba(255,235,120,1.0)',
  GARLAND_COL_OUTER: 'rgba(255,210,80,0.75)',
  GARLAND_SIZE: 2.2,
  GARLAND_BULB_MULTI: 1.6,
  GARLAND_BULB_EVERY: 22,
  GARLAND_TWINKLE_SPEED: 1.2,

  // —— 漂浮粒子（上下都要）——
  SPARK_N: 520,          // 原上方数量
  SPARK_BOTTOM_N: 300,   // ★ 新增：下方数量
  SPARK_XZ_RANGE: 260,   // X/Z 范围
  SPARK_UPPER_Y: [-460, 80], // 上方 y 范围（模型坐标）
  SPARK_BOTTOM_Y: [10, 160], // ★ 下方相对树底的 y 偏移范围（会加到 S.offsetY）
};

const rand=(a=1,b=0)=>Math.random()*(a-b)+b;
const TAU=Math.PI*2;
const angDiff=(a,b)=>{let d=(a-b+Math.PI)%(2*Math.PI)-Math.PI;return d<-Math.PI?d+2*Math.PI:d;};
const smoothStep=x=>x<=0?0:x>=1?1:x*x*(3-2*x);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

// 容器
const tree=[], ring=[], snow=[], trunk=[], star=[], garland=[], spark=[];

// 投影系数
function projFactor(){ return 760/(520+1) * S.zoom; }

// 半宽轮廓（屏幕像素）
function halfWidthScreen(y01, baseW){
  const p=1.0;
  let core=Math.pow(y01,p)*(baseW/2);
  const tier1=y01>0.18?0.014*baseW*Math.sin((y01-0.18)*Math.PI*1.5):0;
  const tier2=y01>0.42?0.018*baseW*Math.sin((y01-0.42)*Math.PI*1.3):0;
  const tier3=y01>0.70?0.022*baseW*Math.sin((y01-0.70)*Math.PI*1.1):0;
  const ripple=0.016*baseW*Math.sin(y01*14 + Math.sin(y01*33));
  return Math.max(6, core + tier1 + tier2 + tier3 + ripple);
}

// 自适应与对称留白
function resize(){
  const cssW=cvs.clientWidth|0, cssH=cvs.clientHeight|0;
  DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1));
  cvs.width=(cssW*DPR)|0; cvs.height=(cssH*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
  S.w=cssW; S.h=cssH; S.cx=cssW/2; S.cy=cssH/2;

  S.zoom = Math.min(S.w, S.h) / 700;

  // 尖端到顶 = 地环中心到底（对称留白）
  const f = projFactor();
  const m = Math.max(0, (S.h - PARAM.H * f) / 2);
  S.offsetY = (m - S.cy)/f + PARAM.H;
}
addEventListener('resize', resize, {passive:true}); resize();

// 构建
function build(){
  tree.length = ring.length = snow.length = trunk.length = star.length = garland.length = spark.length = 0;

  const f = projFactor();
  const baseW_screen = Math.min(S.w*0.7, PARAM.H * f * 0.9);

  // 树杈角度基准
  const branchAngles = Array.from({length:PARAM.BRANCH_COUNT},(_,i)=> i/PARAM.BRANCH_COUNT*TAU);

  // —— 树体（尖端→底部）——
  for(let i=0;i<PARAM.LEVELS;i++){
    const t = i/(PARAM.LEVELS-1);               // 0 顶 → 1 底
    const y_model = -PARAM.H * (1 - t) + S.offsetY;

    const hw_screen = halfWidthScreen(t, baseW_screen);
    const hw_model  = hw_screen / f;

    for(let k=0;k<PARAM.BASE_POINTS;k++){
      let a = Math.random()*TAU;

      // 分支鼓包
      let bulge=0;
      const twist=t*2.0*TAU;
      for(const ba of branchAngles){
        const center=ba+twist;
        const d=Math.abs(angDiff(a,center));
        bulge=Math.max(bulge, Math.exp(-(d*d)/(2*PARAM.BRANCH_SIGMA*PARAM.BRANCH_SIGMA)));
      }
      const gain=smoothStep(1 - Math.abs(t-0.55)/0.55);
      const bulgeFactor = 1 + PARAM.BRANCH_STRENGTH*bulge*gain;

      // 圆盘内取点（√r 边缘更密）
      const r0=Math.sqrt(Math.random()) * hw_model * bulgeFactor;
      let x0=r0*Math.cos(a), z0=r0*Math.sin(a);

      // 向外蓬松推进
      const push_screen = hw_screen * PARAM.FLUFF_PUSH * Math.random();
      const push_model  = push_screen / f;
      x0 += push_model*Math.cos(a);
      z0 += push_model*Math.sin(a);

      const y_jit=rand(3,-3);
      const size = PARAM.DOT_BASE + t*PARAM.DOT_GAIN;

      tree.push({x:x0, y:y_model + y_jit, z:z0, size});

      // 松针喷射
      const L_screen = PARAM.SPRAY_LEN * (0.6 + 0.4*t);
      const L_model  = L_screen / f;
      for(let s=0;s<PARAM.SPRAY_PER_POINT;s++){
        const len=L_model*(0.5+0.5*Math.random());
        const dir=a + rand(PARAM.SPRAY_NOISE, -PARAM.SPRAY_NOISE);
        const off=len*(0.6+0.4*Math.random());
        const x=x0 + off*Math.cos(dir);
        const z=z0 + off*Math.sin(dir);
        const vy=rand(2,-2);
        const sz=size*(0.85+0.3*Math.random());
        tree.push({x,y:y_model+vy,z,size:sz});
      }
    }
  }

  // —— 顶部星星（立体黄色）——
  {
    const starN = PARAM.STAR_N;
    const yCenter = -PARAM.H - 8 + S.offsetY;
    for(let i=0;i<starN;i++){
      const a = i/starN*TAU;
      const r = 10 + 8*Math.sin(5*a);
      const x = rand(0.8,-0.8);
      const z = r*Math.cos(a)*1.05;
      const y = yCenter + r*Math.sin(a)*1.05 + rand(2.5,-2.5);
      star.push({x,y,z,size:3.0});
    }
  }

  // —— 3D 树干（圆柱体）——
  {
    const baseY_model = S.offsetY;
    const h_model = PARAM.TRUNK_HEIGHT_PX / f;
    const r_screen = (baseW_screen/2) * PARAM.TRUNK_RADIUS_RATIO;
    const r_model  = r_screen / f;

    for(let iy=0; iy<PARAM.TRUNK_LEVELS; iy++){
      const ty = iy/(PARAM.TRUNK_LEVELS-1);
      const y = baseY_model + ty*h_model;

      for(let ia=0; ia<PARAM.TRUNK_AROUND; ia++){
        const a = ia/PARAM.TRUNK_AROUND * TAU;
        const rr = r_model * (1 + (Math.random()*2-1)*PARAM.TRUNK_NOISE*0.4);
        const x0 = rr*Math.cos(a);
        const z0 = rr*Math.sin(a);

        const L = 0.55 + 0.45*Math.max(0, Math.cos(a - PARAM.TRUNK_LIGHT_AZIMUTH));
        const [br,bg,bb] = PARAM.TRUNK_COL_BASE;
        const col = `rgba(${Math.round(br*L)},${Math.round(bg*L)},${Math.round(bb*L)},0.95)`;

        trunk.push({x:x0, y, z:z0, size:1.8, col});
        for(let d=0; d<PARAM.TRUNK_DENSITY; d++){
          const off = (Math.random()*0.6+0.2) * (r_model*0.25);
          const dir = a + (Math.random()*2-1)*0.5;
          const xx = x0 + off*Math.cos(dir);
          const zz = z0 + off*Math.sin(dir);
          const yy = y + (Math.random()*2-1) * (h_model*0.02);
          trunk.push({x:xx, y:yy, z:zz, size:1.6, col});
        }
      }
    }
  }

  // —— 黄色灯线（螺旋穿插）——
  {
    const strands = PARAM.GARLAND_STRANDS;
    const turns = PARAM.GARLAND_TURNS;
    const pts = PARAM.GARLAND_POINTS;

    for(let s=0; s<strands; s++){
      const phase0 = (s/strands)*TAU;
      for(let j=0; j<pts; j++){
        const u = 0.06 + 0.88*(j/(pts-1)); // 预留上下留白
        const t = u;
        const f = projFactor();

        const y = -PARAM.H*(1 - t) + S.offsetY + rand(PARAM.GARLAND_JITTER_Y, -PARAM.GARLAND_JITTER_Y);
        const baseW_screen = Math.min(S.w*0.7, PARAM.H * f * 0.9);
        const hw_screen = halfWidthScreen(t, baseW_screen);
        const hw_model  = hw_screen / f;

        const rRatio = PARAM.GARLAND_RADIUS_FACTOR * (0.96 + 0.08*Math.sin(u*8 + s*1.3));
        const rBase  = hw_model * rRatio;

        const twist = t*2.0*TAU;
        const angle = phase0 + u*turns*TAU + rand(PARAM.GARLAND_NOISE, -PARAM.GARLAND_NOISE);

        const x = rBase*Math.cos(angle + twist);
        const z = rBase*Math.sin(angle + twist);

        const isBulb = (j % PARAM.GARLAND_BULB_EVERY) === 0;
        const size = PARAM.GARLAND_SIZE * (isBulb ? PARAM.GARLAND_BULB_MULTI : 1);
        const twPhase = Math.random()*TAU;
        garland.push({x,y,z,size,isBulb, twPhase});
      }
    }
  }

  // —— 地面光环 —— 
  for(let i=0;i<520;i++){
    const a=i/520*TAU, r=PARAM.RING_RADIUS+rand(3,-3);
    const x=r*Math.cos(a), z=r*Math.sin(a), y=(8*Math.sin(a*3)+rand(2,-2)) + S.offsetY;
    ring.push({x,y,z,size:1.7});
  }

  // —— 背景雪 —— 
  for(let i=0;i<PARAM.SNOW_N;i++)
    snow.push({x:rand(1000,-1000), y:rand(-650,650), z:rand(1000,-1000), vy:rand(0.2,0.8), drift:rand(0.6,-0.6), size:1});

  // —— 漂浮粒子（上方 + 下方）——
  {
    // 上方原有
    for(let i=0;i<PARAM.SPARK_N;i++){
      spark.push({
        x: rand(PARAM.SPARK_XZ_RANGE, -PARAM.SPARK_XZ_RANGE),
        y: rand(PARAM.SPARK_UPPER_Y[1], PARAM.SPARK_UPPER_Y[0]),
        z: rand(PARAM.SPARK_XZ_RANGE, -PARAM.SPARK_XZ_RANGE),
        vy: rand(0.15, 0.6),
        size: 0.9
      });
    }
    // ★ 新增：下方，从树底往下延伸一点
    for(let i=0;i<PARAM.SPARK_BOTTOM_N;i++){
      const yOffset = rand(PARAM.SPARK_BOTTOM_Y[1], PARAM.SPARK_BOTTOM_Y[0]); // 相对树底
      spark.push({
        x: rand(PARAM.SPARK_XZ_RANGE, -PARAM.SPARK_XZ_RANGE),
        y: S.offsetY + yOffset,
        z: rand(PARAM.SPARK_XZ_RANGE, -PARAM.SPARK_XZ_RANGE),
        vy: rand(0.10, 0.35), // 下方漂浮更慢一点
        size: 0.9
      });
    }
  }
}
build();
addEventListener('resize', build, {passive:true});

// 投影
function project(p, rot, zoom){
  const c=Math.cos(rot), s=Math.sin(rot);
  const x=p.x*c - p.z*s;
  const z=p.x*s + p.z*c + 520;
  const y=p.y;
  const f=760/(z+1)*zoom;
  return {x:S.cx + x*f, y:S.cy + y*f, r:Math.max(0.7, p.size*f*0.33), z};
}

// 交互
let paused=false, lastPinch=0;
cvs.addEventListener('click', ()=>paused=!paused);
cvs.addEventListener('wheel', e=>{
  e.preventDefault();
  S.zoom *= (e.deltaY>0?0.94:1.06);
  S.zoom = Math.max(0.5, Math.min(2.4, S.zoom));
},{passive:false});
cvs.addEventListener('touchmove', e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    const d=Math.hypot(dx,dy);
    if(lastPinch){ S.zoom*=d/lastPinch; S.zoom=Math.max(0.5,Math.min(2.4,S.zoom)); }
    lastPinch=d;
  }
},{passive:true});
cvs.addEventListener('touchend', ()=>{ lastPinch=0; }, {passive:true});

// 渲染
function draw(){
  if(!paused) S.time += 16.666;
  S.rot = S.time*0.00025;

  // 背景
  const g=ctx.createRadialGradient(S.cx,S.cy+120,10,S.cx,S.cy+120,Math.max(S.w,S.h)*0.7);
  g.addColorStop(0,"#140A14"); g.addColorStop(1,"#000");
  ctx.fillStyle=g; ctx.fillRect(0,0,S.w,S.h);

  // 雪
  ctx.fillStyle="rgba(255,255,255,0.6)";
  for(const s of snow){
    s.y += s.vy; s.x += Math.sin((S.time*0.001 + s.z)*0.2)*0.2 + (Math.random()*2-1)*0.02;
    if(s.y>680){ s.y=-680; s.x=rand(1000,-1000); s.z=rand(1000,-1000); }
    const p=project(s, S.rot*0.3, S.zoom);
    ctx.beginPath(); ctx.arc(p.x,p.y, Math.max(0.4, s.size*p.r*0.35), 0, TAU); ctx.fill();
  }

  // 树干（先画）
  {
    const dots = trunk.map(pt=>project(pt, S.rot, S.zoom))
                      .filter(p=>p.z>0).sort((a,b)=>b.z-a.z);
    for(let i=0;i<dots.length;i++){
      const p=dots[i];
      ctx.beginPath();
      ctx.fillStyle = trunk[i].col;
      ctx.arc(p.x,p.y,p.r,0,TAU);
      ctx.fill();
    }
  }

  // 树体 & 地环
  {
    const dots = tree.concat(ring).map(pt=>project(pt, S.rot, S.zoom))
                     .filter(p=>p.z>0).sort((a,b)=>b.z-a.z);
    ctx.fillStyle="rgba(255,200,240,0.95)";
    for(const p of dots){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,TAU); ctx.fill(); }
  }

  // 灯线（发光+闪烁）
  {
    const t = S.time/1000 * PARAM.GARLAND_TWINKLE_SPEED;
    const dots = garland.map(pt=>project(pt, S.rot, S.zoom))
                        .filter(p=>p.z>0).sort((a,b)=>b.z-a.z);
    for(let i=0;i<dots.length;i++){
      const p=dots[i], gpt=garland[i];
      const tw = 0.8 + 0.2*Math.sin(t*2.1 + gpt.twPhase) * (gpt.isBulb?1.2:0.6);
      const R_outer = p.r * (gpt.isBulb ? 2.2 : 1.6);
      const R_inner = p.r * (gpt.isBulb ? 1.05: 0.9);

      ctx.beginPath();
      ctx.globalAlpha = clamp(0.7*tw, 0.25, 0.95);
      ctx.fillStyle = PARAM.GARLAND_COL_OUTER;
      ctx.arc(p.x, p.y, R_outer, 0, TAU);
      ctx.fill();

      ctx.beginPath();
      ctx.globalAlpha = clamp(1.0*tw, 0.5, 1.0);
      ctx.fillStyle = PARAM.GARLAND_COL_INNER;
      ctx.arc(p.x, p.y, R_inner, 0, TAU);
      ctx.fill();
    }
    ctx.globalAlpha = 1.0;
  }

  // 星星（置于最上层）
  {
    const dots = star.map(pt=>project(pt, S.rot, S.zoom))
                     .filter(p=>p.z>0).sort((a,b)=>b.z-a.z);
    for(const p of dots){
      ctx.beginPath();
      ctx.fillStyle = PARAM.STAR_COLOR_OUTER;
      ctx.globalAlpha = 0.85;
      ctx.arc(p.x,p.y,p.r*1.8,0,TAU);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = PARAM.STAR_COLOR_INNER;
      ctx.globalAlpha = 1.0;
      ctx.arc(p.x,p.y,p.r,0,TAU);
      ctx.fill();
    }
    ctx.globalAlpha = 1.0;
  }

  // 漂浮粒子（统一渲染，上下都有）
  ctx.fillStyle="rgba(255,210,245,0.8)";
  for(const sp of spark){
    sp.y += Math.sin((S.time*0.001 + sp.x)*0.8)*0.2 + sp.vy*0.05;
    // 若超过屏幕底部，重置到顶部或树底附近，制造“循环”
    if(sp.y > S.offsetY + 220){
      if(Math.random() < 0.5){
        // 回到上方
        sp.y = rand(PARAM.SPARK_UPPER_Y[1], PARAM.SPARK_UPPER_Y[0]);
      }else{
        // 回到树底附近
        sp.y = S.offsetY + rand(PARAM.SPARK_BOTTOM_Y[0], PARAM.SPARK_BOTTOM_Y[1]/2);
      }
      sp.x = rand(PARAM.SPARK_XZ_RANGE, -PARAM.SPARK_XZ_RANGE);
      sp.z = rand(PARAM.SPARK_XZ_RANGE, -PARAM.SPARK_XZ_RANGE);
    }
    const p=project(sp, S.rot, S.zoom);
    if(p.z>0){
      ctx.beginPath();
      ctx.arc(p.x,p.y, Math.max(0.6, p.r*0.6), 0, TAU);
      ctx.fill();
    }
  }

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
})();
</script>
</body>
</html>
